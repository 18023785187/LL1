{"version":3,"file":"ll1.min.js","mappings":"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","sources":["webpack://ll1/webpack/universalModuleDefinition","webpack://ll1/webpack/bootstrap","webpack://ll1/webpack/runtime/define property getters","webpack://ll1/webpack/runtime/hasOwnProperty shorthand","webpack://ll1/webpack/runtime/make namespace object","webpack://ll1/./node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js","webpack://ll1/./node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js","webpack://ll1/./node_modules/@babel/runtime/helpers/esm/slicedToArray.js","webpack://ll1/./node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js","webpack://ll1/./node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js","webpack://ll1/./node_modules/@babel/runtime/helpers/esm/nonIterableRest.js","webpack://ll1/./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js","webpack://ll1/./node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js","webpack://ll1/./node_modules/@babel/runtime/helpers/esm/iterableToArray.js","webpack://ll1/./node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js","webpack://ll1/./src/constants.js","webpack://ll1/./src/utils.js","webpack://ll1/./src/splitGrammars.js","webpack://ll1/./src/makeFirstSet.js","webpack://ll1/./src/makeFollowSet.js","webpack://ll1/./src/makeSelectSet.js","webpack://ll1/./src/makePredictSet.js","webpack://ll1/./src/index.js"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ll1\"] = factory();\n\telse\n\t\troot[\"ll1\"] = factory();\n})(this, () => {\nreturn ","// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","export default function _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}","import arrayLikeToArray from \"./arrayLikeToArray.js\";\nexport default function _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);\n}","import arrayWithHoles from \"./arrayWithHoles.js\";\nimport iterableToArrayLimit from \"./iterableToArrayLimit.js\";\nimport unsupportedIterableToArray from \"./unsupportedIterableToArray.js\";\nimport nonIterableRest from \"./nonIterableRest.js\";\nexport default function _slicedToArray(arr, i) {\n  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();\n}","export default function _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}","export default function _iterableToArrayLimit(arr, i) {\n  var _i = null == arr ? null : \"undefined\" != typeof Symbol && arr[Symbol.iterator] || arr[\"@@iterator\"];\n  if (null != _i) {\n    var _s,\n      _e,\n      _x,\n      _r,\n      _arr = [],\n      _n = !0,\n      _d = !1;\n    try {\n      if (_x = (_i = _i.call(arr)).next, 0 === i) {\n        if (Object(_i) !== _i) return;\n        _n = !1;\n      } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0);\n    } catch (err) {\n      _d = !0, _e = err;\n    } finally {\n      try {\n        if (!_n && null != _i[\"return\"] && (_r = _i[\"return\"](), Object(_r) !== _r)) return;\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n    return _arr;\n  }\n}","export default function _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}","import arrayWithoutHoles from \"./arrayWithoutHoles.js\";\nimport iterableToArray from \"./iterableToArray.js\";\nimport unsupportedIterableToArray from \"./unsupportedIterableToArray.js\";\nimport nonIterableSpread from \"./nonIterableSpread.js\";\nexport default function _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();\n}","import arrayLikeToArray from \"./arrayLikeToArray.js\";\nexport default function _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return arrayLikeToArray(arr);\n}","export default function _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}","export default function _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}","export const EMPTY_CHAIN = null;\nexport const OR = '|';\nexport const $ = '$';\n","\nexport function mergeSet(set1, set2) {\n  return new Set([...set1, ...set2]);\n}\n\nexport function isBlank(char) {\n  return char === ' ' || char === '\\t' || char === '\\n' || char === '\\r'\n}\n","import { EMPTY_CHAIN, OR } from './constants.js';\nimport { isBlank } from './utils.js'\n\n/**\n * 生成式必须以空格作为分隔符，以 | 作为或，以 null 作为空串\n * \n * 如: 1、['E -> ( id ) | null']\n *     2、['E -> ( id )', 'E -> null']\n * \n * 无论使用哪种写法最后返回的都会合并成一项，即合并成第一种写法的格式\n */\nexport function splitGrammars(grammars) {\n  const rules = [];\n  const ruleMap = new Map(); // 用于缓存已经创建的产生式，避免重复创建相关的产生式\n\n  for (let i = 0; i < grammars.length; ++i) {\n    const grammar = grammars[i];\n    let [left, right] = grammar.split('->');\n    if (!right || !right.trim()) throw new Error('Grammar is missing the right side');\n\n    let isDefined = true;\n    if (!ruleMap.has(left)) {\n      isDefined = false;\n      ruleMap.set(left, {\n        left: null,\n        right: []\n      });\n    }\n    const grammarRule = ruleMap.get(left);\n    grammarRule.left = left.trim();\n\n    let fragment = [];\n    let str = '';\n    right += ' ';\n    for (let j = 0; j < right.length; ++j) {\n      const char = right[j];\n\n      if (isBlank(char)) {\n        if (str === 'null') {\n          fragment.push(EMPTY_CHAIN);\n        } else if (str) {\n          fragment.push(str);\n        }\n        str = '';\n      } else if (char === '|') {\n        grammarRule.right.push(fragment);\n        fragment = [];\n        str = '';\n      } else {\n        str += char;\n      }\n    }\n\n    if (fragment.length) grammarRule.right.push(fragment);\n    !isDefined && rules.push(grammarRule);\n  }\n\n  return rules;\n}\n\nexport function toGrammars(rules, isExpand = false) {\n  const grammars = [];\n\n  rules.forEach(({ left, right }) => {\n    if (isExpand) {\n      right.forEach(r => {\n        let grammar = '';\n\n        grammar += `${left} -> ${r.map(chain => chain + '').join(' ')}`;\n        grammars.push(grammar);\n      });\n    } else {\n      let grammar = '';\n\n      grammar += `${left} -> `;\n      right.forEach(r => {\n        grammar += r.map(chain => chain + '').join(' ') + ` ${OR} `;\n      });\n\n      grammars.push(grammar.slice(0, -3));\n    }\n  });\n\n  return grammars;\n}\n\n/**\n * 基于 splitGrammars 方法返回的 rules 进行提取公共因子\n * \n * 提取公共因子产生的新表达式用原表达式加 ' 表示，如有多个公共因子以此类推，如：\n * \n *  E -> + a | + b | * c | * d | y\n * \n * 提取后为\n * \n *  E -> + E' | * E'' | y\n *  E' -> a | b\n *  E'' -> c | d\n */\nexport function combineLikeTerms(rules) {\n  const mergeRight = (right) => [...right.map(grammar => [...grammar])];\n  const rightToString = (right) => right.join(OR);\n  const newRules = [];\n\n  const commonSuffix = new Map(); /** 复用已有产生式或提取公共因子后剩余后缀的产生式 */\n  rules.forEach(({ left, right }) => {\n    commonSuffix.set(rightToString(right), left);\n  });\n\n  rules.forEach(({ left, right }) => {\n    handleRule(left, right, new Map());\n  });\n\n  function handleRule(left, right) {\n    commonSuffix.set(rightToString(right), left);\n\n    let repeat = 0;\n    let isInsertRoot = false; // 标记新产生式是否已推入 newRules\n    const grammarRule = {\n      left,\n      right: []\n    };\n\n    if (right.length === 1) {\n      grammarRule.right = mergeRight(right);\n      newRules.push(grammarRule);\n      return;\n    }\n\n    let prefix;\n    let chain;\n    const skips = []; // 存储已合并的项下标\n    for (let i = 0; i < right.length; ++i) { // 以当前产生式右边为参考系\n      if (skips.includes(i)) continue;\n      skips.push(i);\n\n      if (i === right.length - 1) {\n        grammarRule.right.push(right[i]);\n        return;\n      }\n\n      const grammar = right[i];\n      let pos = 0;\n\n      const commonGrammars = [];\n      commonGrammars.push(grammar);\n\n      prefix = '';\n      setPrefix:\n      while (pos < grammar.length) { // 当前产生式右边到尽头时，结束遍历\n        chain = grammar[pos];\n\n        let isEqualChain = false;\n        if (pos === 0) {\n          for (let j = i + 1; j < right.length; ++j) {\n            const curGrammar = right[j];\n            const curChain = curGrammar[pos];\n            if (!curChain) continue;\n\n            if (curChain === chain) {\n              isEqualChain = true;\n              skips.push(j);\n\n              commonGrammars.push(right[j]);\n            }\n          }\n        } else {\n          for (let j = i + 1; j < right.length; ++j) {\n            const curGrammar = right[j];\n            const curChain = curGrammar[pos];\n            if (!curChain || curChain !== chain || !skips.includes(j)) continue;\n            isEqualChain = true;\n          }\n        }\n        if (!isEqualChain) break setPrefix;\n\n        prefix += chain + OR;\n        pos++;\n      }\n\n      if (prefix) {\n        const suffixes = commonGrammars.map(exp => {\n          const suffix = exp.slice(prefix.slice(0, -1).split(OR).length);\n          if (!suffix.length) return [EMPTY_CHAIN];\n          return suffix;\n        });\n\n        let newLeft;\n        if (commonSuffix.has(rightToString(suffixes))) {\n          newLeft = commonSuffix.get(rightToString(suffixes));\n        } else {\n          newLeft = `${left}${\"'\".repeat(repeat)}'`;\n        }\n        const newRight = [...prefix.slice(0, -1).split(OR), newLeft];\n        grammarRule.right.push(newRight);\n        if (!isInsertRoot) {\n          newRules.push(grammarRule);\n          repeat++;\n        };\n\n        if (!commonSuffix.has(rightToString(suffixes)))\n          handleRule(newLeft, suffixes);\n      } else {\n        grammarRule.right.push([...right[i]]);\n        if (!isInsertRoot) {\n          newRules.push(grammarRule);\n        };\n      }\n      isInsertRoot = true;\n    }\n  }\n  return newRules;\n}\n\n/**\n * 基于 splitGrammars 方法返回的 rules 进行消除左递归\n * \n * 左递归分为直接左递归和间接左递归，直接左递归调用 clearDirectLeftRecursion 函数进行消除，间接左递归通过代入产生式降级为直接左递归进行消除，\n * 为了与提取公共因子进行区分，消除左递归引入的新产生式用 ` 标记，如：E -> E + T 消除后得 E -> T E`  E` -> + T E` | null\n * \n * A -> A a1 | A a2 | ... | A an | b1 | b2 | ... | bm\n * \n * ---->\n * \n *  A -> b1A` | b2A` | ... | bmA`\n *  A' -> a1A` | a2A` | ... | anA` | null\n * \n */\nexport function clearLeftRecursion(rules) {\n  const newRules = [];\n\n  rules.forEach(rule => {\n    newRules.push(\n      ...clearDirectLeftRecursion(rule)\n    );\n  });\n\n  function clearDirectLeftRecursion(\n    { left, right } /** rule */\n  ) {\n    const rules = [];\n    const newLeft = `${left}\\``;\n\n    const prefixGrammars = [];\n    const grammars = [];\n    let isEmpty = false;\n    right.forEach(grammar => {\n      if (grammar[0] === left) {\n        grammar.shift();\n        grammar.push(newLeft);\n        prefixGrammars.push(grammar);\n      } else if (grammar[0] === EMPTY_CHAIN) {\n        isEmpty = true;\n      } else {\n        grammar.push(newLeft);\n        grammars.push(grammar);\n      }\n    });\n\n    if (isEmpty) {\n      grammars.push([newLeft]);\n    }\n\n    rules.push(\n      {\n        left,\n        right: [...grammars]\n      },\n      {\n        left: newLeft,\n        right: [...prefixGrammars, [EMPTY_CHAIN]]\n      }\n    );\n\n    return rules;\n  }\n\n  return newRules;\n}\n","import { mergeSet } from './utils.js';\nimport { EMPTY_CHAIN, $ } from './constants.js';\n\n/**\n  1、依次遍历所有产生式，把串首终结符加入其 FIRST 集中。\n  2、如果最左串是非终结符，则把该非终结符的 FIRST 集推入到当前产生式中，如果该非终结符包含空，那么把该非终结符的 FIRST 集 - 空推入到当前产生式中，同时把该非终结符的下一个非终结符的 FIRST 集推入到当前产生式中，重复第二步直至遇到没有包含空的非终结符为止。\n  3、重新遍历所有产生式，重复执行步骤 1、2，直至所有产生式均无变化。\n */\nexport function makeFirstSet(rules, terminalSymbols) {\n  const isTerminal = (chain) => terminalSymbols.includes(chain) || chain === EMPTY_CHAIN;\n\n  const firstSet = {};\n  rules.forEach(({ left }) => firstSet[left] = []);\n\n  let isSetChanged;\n  do {\n    isSetChanged = false;\n    rules.forEach(({ left, right }) => {\n      let sets = new Set(firstSet[left]);\n      const prevLength = sets.size;\n\n      // 处理诸如 E -> A | B 的情况需要遍历\n      right.forEach(grammar => {\n        let first = 0;\n        let chain = grammar[first];\n\n        while (chain?.[0] === $) {\n          chain = grammar[++first];\n        }\n\n        if (isTerminal(chain)) sets.add(chain);\n        else if (firstSet[chain].includes(EMPTY_CHAIN)) {\n\n          do {\n            const nextSet = new Set(firstSet[chain]);\n            nextSet.delete(EMPTY_CHAIN);\n            sets = mergeSet(sets, nextSet);\n            first += 1;\n            chain = grammar[first];\n\n            while (chain?.[0] === $) {\n              chain = grammar[++first];\n            }\n\n          } while (firstSet[chain]?.includes(EMPTY_CHAIN));\n\n          if (isTerminal(chain)) sets.add(chain);\n          else if(chain) sets = mergeSet(sets, firstSet[chain]);\n        }\n        else sets = mergeSet(sets, firstSet[chain]);\n      });\n\n      firstSet[left] = [...sets];\n      if (prevLength !== sets.size) isSetChanged = true;\n    });\n\n  } while (isSetChanged);\n\n  return firstSet;\n}\n\nexport function makeUnionFirstSet(chainSet, firstSet, terminalSymbols) {\n  const isTerminal = (chain) => terminalSymbols.includes(chain) || chain === EMPTY_CHAIN;\n\n  const unionFirstSet = [];\n\n  chainSet.some(chain => {\n    if(chain[0] === $) return false\n    if (isTerminal(chain)) {\n      unionFirstSet.push(chain);\n    } else if (!firstSet[chain].includes(EMPTY_CHAIN)) {\n      unionFirstSet.push(...firstSet[chain]);\n    } else {\n      return false;\n    }\n    return true;\n  });\n\n  return unionFirstSet;\n}\n","import { makeFirstSet } from './makeFirstSet.js';\nimport { mergeSet } from './utils.js';\nimport { EMPTY_CHAIN, $ } from './constants.js';\n\n/**\n    设有式子 S -> (L) | aL | LC，规则如下：\n  1、如果 L 的右边是终结符，那么把这个终结符加到 L 的 FOLLOW 集中。\n  2、如果 L 的右边是非终结符，那么把这个非终结符的 FIRST 集 - 空 加到 L 的 FOLLOW 集中。\n  3、如果 L 处在末尾，那么把 -> 左边符号的 FOLLOW 集 加入到 L 的 FOLLOW 集中。\n  4、当 L 的式子包含空时，对 L 的左边非终结符采用 1、2、3 规则，依次类推。\n\n  推导过程\n\n  1、在第一个产生式加入 $ 作为终止符。\n  2、依次遍历产生式，依序遍历产生式右边，对每个串运用规则。\n  3、重复执行步骤 2，直至所有产生式均无变化。\n */\nexport function makeFollowSet(\n  rules,\n  terminalSymbols,\n  firstSet = makeFirstSet(rules, terminalSymbols)\n) {\n  const isTerminal = (chain) => terminalSymbols.includes(chain) || chain === EMPTY_CHAIN;\n\n  const followSet = {};\n  rules.forEach(({ left }) => followSet[left] = []);\n  followSet[rules[0].left].push($);\n\n  const emptySet = new Set();\n  for (const tag in firstSet) firstSet[tag].includes(EMPTY_CHAIN) && emptySet.add(tag);\n\n  let isSetChanged;\n  do {\n\n    isSetChanged = false;\n    rules.forEach(({ left, right }) => {\n      right.forEach(grammar => {\n        for (let i = grammar.length - 1; i >= 0; --i) {\n          const chain = grammar[i];\n\n          if (isTerminal(chain) || chain[0] === $) continue;\n\n          let prevLength = followSet[chain].length;\n          if (i === grammar.length - 1) {\n            followSet[chain] = [...mergeSet(followSet[chain], followSet[left])];\n          } else {\n            let j = i + 1;\n            let nextChain = grammar[j];\n\n            while(j < grammar.length && nextChain[0] === $) {\n              nextChain = grammar[++j]\n            }\n\n            if (isTerminal(nextChain)) {\n              followSet[chain] = [...mergeSet(followSet[chain], [nextChain])];\n            } else {\n              const nextSet = new Set(firstSet[nextChain]);\n              nextSet.delete(EMPTY_CHAIN);\n              followSet[chain] = [...mergeSet(followSet[chain], nextSet)];\n\n              while (j < grammar.length && (emptySet.has(nextChain) || nextChain[0] === $)) nextChain = grammar[++j];\n              if (j === grammar.length) followSet[chain] = [...mergeSet(followSet[chain], followSet[left])];\n            }\n          }\n\n          if (followSet[chain].length !== prevLength) isSetChanged = true;\n        }\n      });\n    });\n\n  } while (isSetChanged);\n\n  return followSet;\n}\n","import { makeFirstSet, makeUnionFirstSet } from './makeFirstSet.js';\nimport { makeFollowSet } from './makeFollowSet.js';\nimport { mergeSet } from './utils.js';\nimport { EMPTY_CHAIN, $ } from './constants.js';\n\n/**\n  对于形似 A -> ab 的产生式，其 SELECT 集为 FIRST(ab)。\n  对于形似 A -> null 的产生式，其 SELECT 集为 FOLLOW(A)。\n\n  推导过程\n\n    1、对每个产生式进行拆分，如：\n    E -> id | null 拆分成 E -> id，E -> null。\n    2、运用规则求出每个产生式的 SELECT 集。\n */\nexport function makeSelectSet(\n  rules,\n  terminalSymbols,\n  firstSet = makeFirstSet(rules, terminalSymbols),\n  followSet = makeFollowSet(rules, terminalSymbols)\n) {\n  const selectSet = new Map();\n\n  rules.forEach(({ left, right }) => {\n    right.forEach(chainSet => {\n      let pos = 0\n      let chain = chainSet[pos];\n      const newRule = { left, right: chainSet };\n\n      while(pos < chainSet.length && chain && chain[0] === $) {\n        chain = chainSet[++pos]\n      }\n\n      if (chain === EMPTY_CHAIN) {\n        selectSet.set(newRule, followSet[left]);\n      } else {\n        selectSet.set(newRule, makeUnionFirstSet(chainSet, firstSet, terminalSymbols));\n      }\n    });\n  });\n\n  return selectSet;\n}\n\nexport function isNotIntersect(selectSet) {\n  const map = new Map();\n\n  for (const [{ left }, sets] of selectSet) {\n    if (map.has(left)) {\n      const prevSets = map.get(left);\n      const newSets = mergeSet(prevSets, sets);\n      if (newSets.size !== prevSets.size + sets.length) {\n        return false;\n      }\n      map.set(left, newSets);\n    } else {\n      map.set(left, new Set(sets));\n    }\n  }\n\n  return true;\n}\n","import { isNotIntersect } from './makeSelectSet.js';\n\nexport function makePredictSet(selectSet) {\n  if (!isNotIntersect(selectSet))\n    throw new Error('Select set does not satisfy the LL(1) grammar');\n\n  const predictSet = new Map();\n\n  for (const [{ left, right }, sets] of selectSet) {\n    sets.forEach(chain => {\n      if (!predictSet.has(chain)) predictSet.set(chain, new Map());\n\n      const chainMap = predictSet.get(chain);\n\n      chainMap.set(left, right);\n    });\n  }\n\n  return predictSet;\n}\n","// run npx babel-node index.js\nimport { splitGrammars, toGrammars, combineLikeTerms, clearLeftRecursion } from './splitGrammars.js';\nimport { makeFirstSet, makeUnionFirstSet } from './makeFirstSet.js';\nimport { makeFollowSet } from './makeFollowSet.js';\nimport { makeSelectSet, isNotIntersect } from './makeSelectSet.js';\nimport { makePredictSet } from './makePredictSet.js';\nimport { EMPTY_CHAIN, $ } from './constants.js';\n\nfunction makeLL1(grammars, terminalSymbols) {\n  const rules = splitGrammars(grammars);\n\n  const firstSet = makeFirstSet(rules, terminalSymbols);\n  const followSet = makeFollowSet(rules, terminalSymbols, firstSet);\n  const selectSet = makeSelectSet(rules, terminalSymbols, firstSet, followSet);\n  const predictSet = makePredictSet(selectSet);\n\n  return {\n    startSymbol: rules[0].left,\n    firstSet,\n    followSet,\n    selectSet,\n    predictSet,\n    print() {\n      const leftSet = [];\n      const chainSet = [];\n\n      const indent = 2;\n      let maxLength = indent;\n\n      for (const [chain] of predictSet) {\n        chainSet.push(chain);\n        maxLength = Math.max(maxLength, chain.length + indent);\n      }\n      for (const left in firstSet) {\n        leftSet.push(left);\n        maxLength = Math.max(maxLength, left.length + indent);\n      }\n\n      const result = new Array(leftSet.length + 1).fill([]).map(() => new Array(chainSet.length + 1).fill(''));\n\n      for (let i = 0; i < chainSet.length; ++i) {\n        result[0][i + 1] = chainSet[i];\n      }\n      for (let i = 0; i < leftSet.length; ++i) {\n        result[i + 1][0] = leftSet[i];\n      }\n\n      for (const [chain, ruleMap] of predictSet) {\n        const col = result[0].indexOf(chain);\n        let row;\n\n        for (const [left, right] of ruleMap) {\n          for (let i = 0; i < leftSet.length; ++i) {\n            if (result[i + 1][0] === left) {\n              row = i + 1;\n              break;\n            }\n          }\n\n          result[row][col] = `-> ${right.map(item => item + '').join(' ')}`;\n\n          maxLength = Math.max(maxLength, result[row][col].length + indent);\n        }\n      }\n\n      let colLength = (maxLength + indent);\n      let logStr = '';\n      let splitStr = '\\n' + ('|' + '-'.repeat(colLength)).repeat(chainSet.length + 1) + '|\\n';\n      for (let i = 0; i < result.length; ++i) {\n        logStr += splitStr + '|';\n\n        for (let j = 0; j < result[i].length; ++j) {\n          const term = i === 0 || j === 0 ?\n            \" \\x1b[33;1m \" + result[i][j] + \" \\x1b[0m \" :\n            \" \\x1b[32;1m \" + result[i][j] + \" \\x1b[0m \";\n          logStr += term + ' '.repeat(maxLength + 13 - term.length) + '|';\n        }\n      }\n      logStr += splitStr;\n      console.log(logStr);\n    }\n  };\n}\n\nexport {\n  makeLL1,\n  splitGrammars,\n  toGrammars,\n  combineLikeTerms,\n  clearLeftRecursion,\n  makeFirstSet,\n  makeUnionFirstSet,\n  makeFollowSet,\n  makeSelectSet,\n  isNotIntersect,\n  makePredictSet,\n  EMPTY_CHAIN,\n  $,\n};\n"],"names":["root","factory","exports","module","define","amd","this","__webpack_require__","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","_arrayLikeToArray","arr","len","length","i","arr2","Array","_unsupportedIterableToArray","minLen","n","toString","slice","constructor","name","from","test","_slicedToArray","isArray","_i","iterator","_s","_e","_x","_r","_arr","_n","_d","next","done","push","err","TypeError","_toConsumableArray","iter","EMPTY_CHAIN","OR","$","mergeSet","set1","set2","Set","isBlank","char","splitGrammars","grammars","rules","ruleMap","Map","split","left","right","trim","Error","isDefined","has","set","grammarRule","fragment","str","j","toGrammars","isExpand","forEach","r","grammar","map","chain","join","combineLikeTerms","rightToString","newRules","commonSuffix","handleRule","prefix","repeat","isInsertRoot","mergeRight","skips","includes","pos","commonGrammars","setPrefix","isEqualChain","curChain","suffixes","exp","suffix","newLeft","newRight","clearLeftRecursion","rule","prefixGrammars","isEmpty","shift","clearDirectLeftRecursion","makeFirstSet","terminalSymbols","isSetChanged","isTerminal","firstSet","sets","prevLength","size","first","add","nextSet","makeUnionFirstSet","chainSet","unionFirstSet","some","makeFollowSet","followSet","emptySet","tag","nextChain","makeSelectSet","selectSet","newRule","isNotIntersect","prevSets","newSets","makePredictSet","predictSet","makeLL1","startSymbol","print","leftSet","maxLength","Math","max","result","fill","col","indexOf","row","item","logStr","splitStr","term","console","log"],"sourceRoot":""}